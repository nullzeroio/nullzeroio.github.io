<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>NullZero</title>
 <link href="http://www.nullzero.io/atom.xml" rel="self"/>
 <link href="http://www.nullzero.io/"/>
 <updated>2017-08-31T00:54:59-04:00</updated>
 <id>http://www.nullzero.io</id>
 <author>
   <name>Kevin Kirkpatrick</name>
   <email>kevin@nullzero.io</email>
 </author>

 
 <entry>
   <title>WorkLog PowerShell Module</title>
   <link href="http://www.nullzero.io/powershell/2015/02/06/worklog-powershell-module/"/>
   <updated>2015-02-06T10:50:06-05:00</updated>
   <id>http://www.nullzero.io/powershell/2015/02/06/worklog-powershell-module</id>
   <content type="html">&lt;p&gt;As part of a new initiative, of sorts, I wanted a way to record daily accomplishments, which¬†is something that I have thought about doing for quite some time, but never got enough motivation to actually do anything about it. That said, I decided to revisit, take action and come up with some requirements¬†on what a¬†workable solution would look like (for me):&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;It needs to be easy to record entries (if it‚Äôs hard or cumbersome, it won‚Äôt have sustainability)&lt;/li&gt;
  &lt;li&gt;It needs to fit into my daily workflow&lt;/li&gt;
  &lt;li&gt;The format needs to be somewhat open/easy to move between different platforms¬†(Mainly Windows &amp;amp; Mac OS)&lt;/li&gt;
  &lt;li&gt;If possible, pick a solution that can sharpen a skill-set, in the process&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given each of those, my final solution ended up being quite simple: GitHub and GitHub Flavored Markdown (GFM) files. This was ideal, because it really meets all of the requirements, above.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;It needs to be easy to record entries
    &lt;ul&gt;
      &lt;li&gt;Use Sublime Text to create/edit GFM files for each day.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;It needs to fit into my daily workflow
    &lt;ul&gt;
      &lt;li&gt;I already use GitHub on a daily basis¬†for source control of various scripts, projects, modules, etc.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;The format needs to be somewhat open/easy to move between different platforms
    &lt;ul&gt;
      &lt;li&gt;Again, I already use GitHub as a central source control for all of my code repositories and have that synced between my Windows and Mac systems&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;If possible, pick a solution that can sharpen a skill-set, in the process
    &lt;ul&gt;
      &lt;li&gt;While familiar with GitHub and GFM files, I can always use some extra practice&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now, after I started building out how I wanted things setup and started creating entries into a log file, I realized that flipping over to a text editor to make entries was working fine, but I wanted deeper integration; why not use PowerShell!&lt;/p&gt;

&lt;p&gt;What resulted was a PowerShell module comprised of 3 functions:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;New-WorkLog&lt;/li&gt;
  &lt;li&gt;Add-WorkLog&lt;/li&gt;
  &lt;li&gt;Get-WorkLog&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The main functionality I needed out of this module was:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Create a new Work Log file for each day&lt;/li&gt;
  &lt;li&gt;Standard file name format&lt;/li&gt;
  &lt;li&gt;Generate pre-formatted file layout (Title, fully formatted date and an initial bullet point)&lt;/li&gt;
  &lt;li&gt;Ability to add entries right from the PowerShell console&lt;/li&gt;
  &lt;li&gt;Ability to view the contents of the Work Log for the current day, from within the console&lt;/li&gt;
  &lt;li&gt;Basic support for bullet point indentation&lt;/li&gt;
  &lt;li&gt;Basic fail-safes so that files wouldn‚Äôt get overwritten.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Before I continue, you can get more information as well as download, clone or fork the Module from &lt;a href=&quot;https://github.com/vScripter/WorkLogModule&quot; target=&quot;_blank&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Lets take a closer look at each function.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;new-worklog&quot;&gt;New-Worklog&lt;/h2&gt;

&lt;h3 id=&quot;function-header&quot;&gt;Function header&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function New-WorkLog {

  [cmdletbinding()]
  param (
	[parameter(Mandatory = $false)]
	[System.String]$Path = &quot;$ENV:USERPROFILE\Documents\GitHub\WorkLog&quot;
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Pretty standard material getting things started. The main item worth noting is that I hard coded the working directory and assigned it to the -Path parameter.&lt;/p&gt;

&lt;h3 id=&quot;begin-block&quot;&gt;BEGIN Block&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;BEGIN {

  $now        = Get-Date
  $dateFormat = $now.tostring(&#39;yyyyMMdd&#39;)
  $dateDay    = $now.tostring(&#39;dddd&#39;)
  $fileName   = $dateFormat + &#39;_&#39; + $dateDay + &#39;_&#39; + &#39;WL.md&#39;
  $filePath   = Join-Path $Path $fileName
  $nowLong    = $now.tostring(&#39;D&#39;)

} # end BEGIN block
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;I need to get some date details and convert them to strings so that I can create a custom, standard file name as well as the date detail that will get stored in the actual file.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$now&lt;/code&gt; - Get and assign¬†the current date information in the $now variable, so that we can use to construct our custom file format.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$dateFormat&lt;/code&gt; - Call the .tostring() method on the $now variable and format the output so it will look like ‚Äò20150205‚Äô&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$dateDay&lt;/code&gt; - Call the .tostring() method but specify ‚Äòdddd‚Äô in order to get the day of the week in long format, like ‚ÄòThursday‚Äô&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$fileName&lt;/code&gt; - Build¬†out the actual file name string. I‚Äôm adding¬†the value stored in $dateFormat;¬†then add an¬†underscore ‚Äò_‚Äô; then add the value stored in $dateDay; then another underscore ‚Äò_‚Äô; finally, add the last piece ‚ÄòWL.md‚Äô (‚ÄòWL‚Äô just stands for Work Log)&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$filePath&lt;/code&gt; - Join the value stored in &lt;code class=&quot;highlighter-rouge&quot;&gt;$Path&lt;/code&gt; with the value stored in &lt;code class=&quot;highlighter-rouge&quot;&gt;$fileName&lt;/code&gt;, and the end result is the full path of the daily Work log file, which looks something like: &lt;code class=&quot;highlighter-rouge&quot;&gt;C:\Users\%USERNAME%\Documents\GitHub\WorkLog\20150205_Thursday_WL.md&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;process-block&quot;&gt;PROCESS Block&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PROCESS {

		if (-not (Test-Path -LiteralPath $filePath -PathType Leaf)) {

			try {

				Write-Verbose -Message &#39;Creating worklog file&#39;
				New-Item -Path $filePath -Type File -ErrorAction &#39;Stop&#39; | Out-Null

				Write-Verbose -Message &#39;Adding message to Work Log&#39;
				Write-Output -InputObject &#39;## Work Log &#39; | Out-File -LiteralPath $filePath -Append
				Write-Output -InputObject &quot;### $nowLong&quot; | Out-File -LiteralPath $filePath -Append
				Write-Output -InputObject &#39; &#39; | Out-File -LiteralPath $filePath -Append
				Write-Output -InputObject &#39;* &#39; | Out-File -LiteralPath $filePath -Append

				if (Test-Path -LiteralPath $filePath -PathType Leaf) {

					Write-Verbose -Message &#39;Work Log file created successfully&#39;

				} else {

					Write-Verbose -Message &#39;Work Log file not created&#39;

				} # end if/else Test-Path

			} catch {

				Write-Warning -Message &quot;Error creating work log file. $_&quot;

			} # end try/catch
		} else {

			Write-Warning -Message &#39;Worklog for today had already been created&#39;

		} # end if/else

	} # end PROCESS block
  ```

* ¬†First, we create a logical statement that tests for the existence of the log file and if it does not exist, we want to create it, but if it does exist, we want to display a message to the console saying that it already exists. Since I only want to take action if it DOES NOT exist, I start by using that criteria as the first validation via &#39;-not&#39; operator. `if (-not (Test-Path -LiteralPath $filePath -PathType Leaf)`

* I then create the desired file and use Write-Output to add the desired detail to the file. As a general comment, the spacing of the text does matter, to a certain degree, when creating these markdown files, since spaces and special characters actually mean something when the markdown files are read/displayed.
* If the file does exist, use Write-Warning to display some text in the console letting me know that one is already created. I used Write-Warning here because I wanted to avoid clouding up the &#39;Output/Success&#39; data stream ([great article](http://blogs.technet.com/b/heyscriptingguy/archive/2014/03/30/understanding-streams-redirection-and-write-host-in-powershell.aspx) by June Blender on PowerShell streams). As a best practice, I ALWAYS try to avoid sending informational messages that are only useful to the user running the cmdlet/script/function, from going down the pipeline; Output from the &#39;Write-Output&#39; cmdlet uses the &#39;Output/Success&#39; stream (stream 1). Write-Host is forbidden and kills kittens, so it should never be used üôÇ (It also sends nothing to any stream, which can very problematic).
* We don&#39;t do anything in the END {} block so we can move on to the next function

* * *


## Add-Workload

### Function Header
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;function Add-WorkLog {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[cmdletbinding()]
param (
    [parameter(Mandatory = $true,
               Position = 0)]
    [System.String]$Message,

    [parameter(Mandatory = $false,
               Position = 1)]
    [System.String]$Path = &quot;$ENV:USERPROFILE\Documents\GitHub\WorkLog&quot;,

    [parameter(Mandatory = $false,
               Position = 2)]
    [ValidateSet(&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;)]
    [System.String]$Indent
) ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;I needed some parameters to deal with the actual message/update to be entered into the Work Log, as well as an -Indent parameter to specify the level of indentation
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-Message&lt;/code&gt; - This is the string data that will actually be appended into the Work Log file. I set the position at ‚Äò0‚Äô so that I can quickly add entries without having to specify ‚Äò-Message‚Äô before typing the message.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-Indent&lt;/code&gt; - This is the level of desired indentation and is only required if you want to indent the entry. I only want to offer 4 levels of indentation, so I specify a [ValidateSet()] attribute to the parameter with the only values I want to accept (1,2,3,4). These values get passed to a function that actually reads the value and performs the proper indentation spacing when it appends the entry to the Work Log file. More on that in the PROCESS block&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;begin-block-1&quot;&gt;BEGIN Block&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;BEGIN {

		$now        = Get-Date
		$dateFormat = $now.tostring(&#39;yyyyMMdd&#39;)
		$dateDay    = $now.tostring(&#39;dddd&#39;)
		$fileName   = $dateFormat + &#39;_&#39; + $dateDay + &#39;_&#39; + &#39;WL.md&#39;
		$filePath   = Join-Path $Path $fileName
		$nowLong    = $now.tostring(&#39;D&#39;)

		function Add-Indent {
			[cmdletbinding()]
			param (
				[parameter(Mandatory = $true)]
				[System.String]$Level
			)

			switch ($Level) {
				&#39;1&#39; { &#39;  * &#39; }
				&#39;2&#39; { &#39;    * &#39; }
				&#39;3&#39; { &#39;      * &#39; }
				&#39;4&#39; { &#39;        * &#39; }
			} # end switch

		} # end function indent

	} # end BEGIN block
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;I won‚Äôt go over the date variables since we reviewed that in the ‚ÄòNew-WorkLog‚Äô function&lt;/li&gt;
  &lt;li&gt;I created the ‚ÄòAdd-Indent‚Äô function to handle the indentation spacing that results in a properly formatted, indented, markdown file.
    &lt;ul&gt;
      &lt;li&gt;I accept the -Indent parameter, if it was supplied, in the -Level parameter of this function&lt;/li&gt;
      &lt;li&gt;I use a basic ‚Äòswitch‚Äô statement to define the spacing that gets outputted when the function is called. More on this functionality in the PROCESS block&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;process-block-1&quot;&gt;PROCESS Block&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PROCESS {

  if (Test-Path -LiteralPath $filePath) {

      if ($Indent) {

          $indentMessage = $(Add-Indent -Level $Indent) + $Message
          Write-Verbose -Message &#39;Adding message to Work Log&#39;
          Write-Output -InputObject $indentMessage | Out-File $filePath -Append

      } else {

          Write-Verbose -Message &#39;Adding message to Work Log&#39;
          Write-Output -InputObject &quot;* $Message&quot; | Out-File $filePath -Append

      } # end if/else $Indent

  } elseif (-not (Test-Path -LiteralPath $filePath)) {

      Write-Warning -Message &#39;Work log not created&#39;
      try {

          Write-Verbose -Message &#39;Creating worklog file&#39;
          New-Item -Path $filePath -Type File -ErrorAction &#39;Stop&#39; | Out-Null

          if ($Indent) {

              Write-Warning -Message &quot;Since the file has not be created, your &#39;-Indent&#39; input of &#39;$Indent&#39; will be ignored for the first log entry.&quot;

          } # end if $Indent

          Write-Verbose -Message &#39;Adding message to Work Log&#39;
          Write-Output -InputObject &#39;## Work Log &#39; | Out-File -LiteralPath $filePath -Append
          Write-Output -InputObject &quot;### $nowLong&quot; | Out-File -LiteralPath $filePath -Append
          Write-Output -InputObject &#39; &#39; | Out-File -LiteralPath $filePath -Append
          Write-Output -InputObject &quot;* $Message&quot; | Out-File -LiteralPath $filePath -Append

          if (Test-Path -LiteralPath $filePath -PathType Leaf) {

              Write-Verbose -Message &#39;Work Log file created successfully&#39;

          } else {

              Write-Verbose -Message &#39;Work Log file not created&#39;

          } # end if/else

      } catch {

          Write-Warning -Message &quot;Error creating work log file. $_&quot;

      } # end try/catch

  } # end if/elseif

} # end PROCESS block
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;I start with a conditional statement to check and see if the WorkLog file exists and if it does, then check to see if there was a desired indent level.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$indentMessage&lt;/code&gt; - Stores the properly indented message that will be written to the Work Log file. It merges the desired indent with the provided -Message string&lt;/li&gt;
  &lt;li&gt;If no indent is desired, it simply appends the message to the current Work Log file&lt;/li&gt;
  &lt;li&gt;If the Work Log file DOES NOT exist, we want to go ahead and create it. The main differences the way the file gets created with ‚ÄòAdd-WorkLog‚Äô vs. ‚ÄòNew-WorkLog‚Äô are:
    &lt;ul&gt;
      &lt;li&gt;There is no asterisk (bullet point) created as part of the initial file create; if the file doesn‚Äôt exist, we want our first entry to be the first bullet point.&lt;/li&gt;
      &lt;li&gt;Along the same lines, if we supplied an indent level and the file doesn‚Äôt exist, we don‚Äôt want to to indent the first entry, so, I just ignore indents if the file has to be created using this function&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;There is nothing in the END {} block so we will move on to the next function&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;get-worklog&quot;&gt;Get-Worklog&lt;/h2&gt;

&lt;h3 id=&quot;function-header-1&quot;&gt;Function Header&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function Get-WorkLog {

	[cmdletbinding()]
	param (
		[parameter(Mandatory = $false)]
		[System.String]$Path = &quot;$ENV:USERPROFILE\Documents\GitHub\WorkLog&quot;
	)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This isn‚Äôt any different than the start of the New-WorkLog function, so you can reference that if you have any questions&lt;/p&gt;

&lt;h3 id=&quot;begin-block-2&quot;&gt;BEGIN Block&lt;/h3&gt;
&lt;p&gt;This is also no different than the New-WorkLog function; you can reference more detail above&lt;/p&gt;

&lt;h3 id=&quot;process-block-2&quot;&gt;PROCESS Block&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PROCESS {

  if (Test-Path -LiteralPath $filePath -PathType Leaf) {

    Get-Content -LiteralPath $filePath -ReadCount 0

  } else {

    Write-Warning -Message &#39;Work Log file has not been created&#39;

  } # end if/else

} # end PROCESS block
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;This is the most straight forward function, of all the rest. We are just using the Get-Content cmdlet to read in and display the contents of the current work log file.&lt;/li&gt;
  &lt;li&gt;I use the ‚Äò-ReadCount 0‚Äô parameter so that is reads the entire file contents in at one time, instead of line-by-line.&lt;/li&gt;
  &lt;li&gt;If the Work Log file has not been created, display a message to the console&lt;/li&gt;
  &lt;li&gt;There is no END {} block&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;output&quot;&gt;Output&lt;/h2&gt;

&lt;p&gt;Below are some example commands and the file/file format that they produce&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Add-WorkLog &#39;This is the first item of the day&#39;
Add-WorkLog &#39;This is the first sub-item of the day&#39; -Indent 1
Add-WorkLog &#39;This is the first sub-sub-item of the day&#39; -Indent 2
Add-WorkLog &#39;This is the second item of the day&#39;
Add-WorkLog &quot;This is how using back-tick marks through the PowerShell console can be used to ````show code```` in the GFM&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;output-file-name&quot;&gt;Output file name&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;20150206_Friday_WL.md&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;output-file-content&quot;&gt;Output file content&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;## Work Log
### Friday, February 06, 2015

* This is the first item of the day
  * This is the first sub-item of the day
    * This is the first sub-sub-item of the day
* This is the second item of the day
* This is what using back-tick marks through the PowerShell console can be used to ``show code`` in the GFM
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;end-result&quot;&gt;End result&lt;/h4&gt;
</content>
 </entry>
 
 <entry>
   <title>Locked Out of vCenter 5.1</title>
   <link href="http://www.nullzero.io/vsphere%205.x/2013/09/20/locked-out-of-vcenter-5-1/"/>
   <updated>2013-09-20T11:38:39-04:00</updated>
   <id>http://www.nullzero.io/vsphere%205.x/2013/09/20/locked-out-of-vcenter-5-1</id>
   <content type="html">&lt;p&gt;Recently, I was called in to help a client out with a vCenter 5.1 install and came across the somewhat common issue of being locked out of vCenter (which is most common after the upgrade process). After some investigation, it appeared the proper Identity Sources were configured and SSO, in general, looked okay. After scratching our heads a bit, I decided to take a look inside the vCenter DB and verify account/group access. Since this was a clean installation, and not an upgrade, the only account in the vCenter DB was the one specified during the installation wizard. This was a SQL DB, so the table where this access can be found is in the ‚ÄúVMW.VPX_ACCESS‚Äù table, within the vCenter DB.&lt;/p&gt;

&lt;p&gt;Note: If you are going to attempt this procedure, make sure you have a good/valid backup of the entire DB that you can restore.&lt;/p&gt;

&lt;p&gt;To verify/modify access:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Stop all vCenter Services&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Use SQL Management Studio to connect to the DB&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Expand the vCenter DB (in my case, the name is ‚ÄòVCDB‚Äô)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Expand the Tables and right click on the ‚ÄúVMW.VPX_ACCESS‚Äù table; select ‚ÄúEdit Top 200 Rows‚Äù.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;You should see a single row (if this is a new install) with the group/account details that you setup as part of the install wizard, in the ‚ÄúPRINCIPAL‚Äù column.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;http://www.vmotioned.com/wp-content/uploads/2013/09/VPX_ACCESS_1.jpg&quot;&gt;&lt;img src=&quot;http://www.vmotioned.com/wp-content/uploads/2013/09/VPX_ACCESS_1.jpg&quot; alt=&quot;VPX_ACCESS_1&quot; width=&quot;543&quot; height=&quot;69&quot; class=&quot;aligncenter size-full wp-image-429&quot; srcset=&quot;http://www.vmotioned.com/wp-content/uploads/2013/09/VPX_ACCESS_1.jpg 543w, http://www.vmotioned.com/wp-content/uploads/2013/09/VPX_ACCESS_1-300x38.jpg 300w&quot; sizes=&quot;(max-width: 543px) 100vw, 543px&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Make any necessary changes to the account details and close the table&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Restart vCenter services and see if access has been restored&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In this particular scenario, it was found that the client entered the incorrect details during the install wizard, which is why no one was able to access vCenter.&lt;/p&gt;
</content>
 </entry>
 

</feed>
